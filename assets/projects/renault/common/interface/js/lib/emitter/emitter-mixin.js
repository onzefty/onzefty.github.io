import{getRandomID as t}from"../utils/utils.js";const s={};class e{constructor(){this.emitID=t(),s[this.emitID]={},s[this.emitID].listeners={}}get listeners(){const t=s[this.emitID].listeners,e={};for(const s in t){const i=t[s];e[s]=[...i]}return e}get events(){const t={},s=Reflect.ownKeys(this.constructor),e=/([^.\n]+\.)+[^.\n]*/;if(s.forEach((s=>{const i=this.constructor[s],n=e.test(i);"string"==typeof i&&n&&isNaN(i)&&(t[s]=i)})),s.includes("EVENTS")){const s=this.constructor.EVENTS;Reflect.ownKeys(s).forEach((e=>{const i=s[e];"string"==typeof i&&isPotentialEvent&&isNaN(i)&&(t[e]=i)}))}return t}on(t,s){return this.listen(t,s)}once(t,s){return this.listen(t,(t=>{t.off(),s.call(t.target,t)}))}listen(t,e){const i=s[this.emitID].listeners;return Array.isArray(this.listeners[t])||(i[t]=[]),i[t].includes(e)||i[t].push(e),this}has(t,s){return!!this.listeners[t]&&(s?this.listeners[t].includes(s):this.listeners[t].length>0)}off(t,e){const i=s[this.emitID].listeners,n=i[t];if(!t&&!e){const t=Object.keys(i);for(const s of t)delete i[s];return this}if(n)if(e){const t=n.indexOf(e);t>-1&&n.splice(t,1)}else n.length=0;return this}emit(t,s={}){const e=this.listeners[t];if(e){const n=new i(t,this,s);e.forEach((t=>{t.call(n.target,n),n.called&&this.off(n.type,t)}))}return this}}class i{constructor(t,s,e){this.type=t,this.target=s,this.data=e}off(){this.called=!0}}export{e as default};
