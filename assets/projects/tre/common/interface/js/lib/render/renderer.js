import{getUuidv4 as t,noop as e}from"../utils/utils.js";import i from"./renderer-time.js";import a from"../emitter/emitter-mixin.js";const n={};class r extends a{static get ACTIVE(){return"Render.active"}constructor(a){super(),this.id=t(),this.name=this.id,this.fct=e,this.removeCallback=e,this.context=this,this.autoStart=!0,this.launch=!1,this.time=new i,n[this.id]={active:!0},this.set(a)}set active(t){"boolean"==typeof t&&(!0===t&&this.emit(r.ACTIVE),n[this.id].active=t)}get active(){return n[this.id].active}set(t={}){"string"==typeof t.name&&(this.name=t.name),"function"==typeof t.fct&&(this.fct=t.fct),"function"==typeof t.removeCallback&&(this.removeCallback=t.removeCallback),void 0!==t.context&&null!==t.context&&(this.context=t.context),"boolean"==typeof t.autoStart&&(this.autoStart=t.autoStart),"boolean"==typeof t.launch&&(this.launch=t.launch),"boolean"==typeof t.active&&(n[this.id].active=t.active),t.time instanceof i==!0&&(this.time=t.time)}}let s;class d{constructor(t){if(s)return s;s=this,this.renders={},this.time=new i,this.data={started:!1,waitForActiveRender:!1,id:0},this.boundUpdate=this.update.bind(this),this.boundHandleActiveRender=this.handleActiveRender.bind(this),!1!==t&&this.launch()}launch(){this.data.started||(this.time.startTime=performance.now(),this.time.currentTime=this.time.startTime,this.data.started=!0,this.data.id=requestAnimationFrame(this.boundUpdate))}finish(){this.data.started&&(cancelAnimationFrame(this.data.id),this.data.started=!1,this.data.waitForActiveRender=!1)}update(){if(!0===this.data.waitForActiveRender)return;const t=performance.now(),e=this.getAll(),i=[];if(e.forEach((e=>{!0!==e.active?!1!==e.active||e.time.pausedTime||(e.time.pausedTime=t):i.push(e)})),0===i.length)return this.data.waitForActiveRender=!0,void(this.time.pausedTime=t);this.setTime(t,this.time),i.forEach((e=>{e.launch?(this.setTime(t,e.time,this.time),e.fct.call(e.context,{name:e.name,time:e.time})):e.time.startTime||(e.time.startTime=null,e.time.currentTime=null)})),this.data.id=requestAnimationFrame(this.boundUpdate)}setTime(t,e,i){const{startTime:a,pausedTime:n}=e;let r=0;a||(e.startTime=t,e.currentTime=t),n&&a&&(r=t-n,e.localInactiveTime+=r);const{localInactiveTime:s,currentTime:d,startTime:o}=e;i&&(e.globalElapsed=i.localElapsed,e.globalDelta=i.localDelta,e.globalInactiveTime=i.localInactiveTime),e.localDelta=t-d-r,e.currentTime=t,e.localElapsed=t-o-s,e.pausedTime=null}add(t){const i=new r({context:this});if(i.set(t),i.autoStart&&(i.launch=!0),"function"!=typeof i.fct)return void console.warn("Renderer.add: A renderer without valid function tried to be added. It will be ignored.");if(i.fct===e)return void console.warn("Renderer.add: A renderer without mechanism function tried to be added. It will be ignored.");const a=i.name;if(!this.getByName(a))return i.active&&this.handleActiveRender(),i.on(r.ACTIVE,this.boundHandleActiveRender),this.renders[a]=i,i;console.warn(`Renderer.add: A renderer with name "${i.name}" already exists. It will be ignored.`)}remove(t){const e=t.name,i=this.renders[e];i&&(i.removeCallback.call(i.context,{name:e,time:t.time}),i.off(r.ACTIVE,this.boundHandleActiveRender),delete this.renders[e])}removeByFct(t){const e=this.getByFct(t);e&&this.remove(e)}removeByName(t){const e=this.getByName(t);e&&this.remove(e)}getAll(){return Object.values(this.renders)}getAllActive(){return this.getAll().filter((t=>!0===t.active))}getAllInactive(){return this.getAll().filter((t=>!1===t.active))}getByFct(t){return this.getAll().find((e=>e.fct===t))}getByName(t){return this.renders[t]}clear(){this.renders={}}handleActiveRender(){!0===this.data.started&&!0===this.data.waitForActiveRender&&(this.data.waitForActiveRender=!1,this.data.id=requestAnimationFrame(this.boundUpdate))}}export{d as default};
